<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="" xml:lang="">
<head>
  <meta charset="utf-8" />
  <meta name="generator" content="pandoc" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
  <title>Atomic Kotlin: Generics</title>
  <link rel="icon" type="image/x-icon" href="favicon.ico">
  <style type="text/css">
      code{white-space: pre-wrap;}
      span.smallcaps{font-variant: small-caps;}
      span.underline{text-decoration: underline;}
      div.column{display: inline-block; vertical-align: top; width: 50%;}
  </style>
  <link rel="stylesheet" href="atomickotlin-html.css" />
  <!--[if lt IE 9]>
    <script src="//cdnjs.cloudflare.com/ajax/libs/html5shiv/3.7.3/html5shiv-printshiv.min.js"></script>
  <![endif]-->
</head>
<body>
<header>
  <a href="https://atomickotlin.github.io/">
    <img src="Banner.png" alt="Atomic Kotlin" class="banner-image">
  </a>
</header>
<h1 id="generics">Generics</h1>
<blockquote>
<p><strong>This Atom is Under Construction</strong></p>
</blockquote>
<blockquote>
<p>Ordinary classes and functions work with specific types. If you want code that works across more types, this rigidity can be overconstraining.</p>
</blockquote>
<p>[Polymorphism] is an object-oriented generalization tool. You write a function that takes a base class object as an argument, then use that function with any class derived from the base class—including classes that haven’t been created yet. Now your function is more general, and useful in more places.</p>
<p>A single hierarchy can be too limiting because you must inherit <em>from that hierarchy</em> to produce an object that fits your function argument. If a function argument is an interface instead of a class, the limitations are loosened to include anything that implements the interface. This gives the client programmer the option of implementing an interface in combination with an existing class—that is, to <em>adapt</em> an existing class to fit your function. Interfaces cut across class hierarchies, as long as you have the option to implement those interfaces to fit.</p>
<p>Sometimes even an interface is too restrictive. It still requires that your code works with that particular interface. You can write even more general code if you make it work with “some unspecified type,” rather than a specific interface or class.</p>
<p><strong>End of sample. See <a href="https://atomickotlin.github.io/">AtomicKotlin.com</a> for full early-access book.</strong></p>
</body>
</html>
